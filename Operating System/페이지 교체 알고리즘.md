# 페이지 교체 알고리즘
### 목차
1. 요구 페이징
2. 페이지 교체
3. 페이지 교체 알고리즘
<br><br><br>

## 페이지 교체
프로그램 실행시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, **프로세스 동작에 필요한 페이지를 요청하는 과정에서 `페이지 부재(Page fault)` 가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 된다.** 하지만 물리 메모리가 모두 사용중인 상황이라면, 페이지 교체가 이루어져야 한다.
<br><br><br>

## 페이지 교체 알고리즘 (Page Replacment Algorithm)
<br>

#### FIFO
```
FIFO 구조로, 메모리에 먼저 올라온 페이지를 먼저 내보내는 알고리즘.
```

##### 특징
- 이해하기도 쉽고, 구현이 간단하다.
- 페이지의 향후 참조 가능성을 고려하지 않고, 물리 메모리에 들어온 순서대로 교체될 대상을 선정하기 때문에, 비 효율적인 상황이 발생할 수 있다.
- 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다.
- **`Belady 의 모순`** : 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.
<br><br><br>

#### OPT (Optimal Page Replacement)
```
앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체하는 방식의 알고리즘
```

##### 특징
- Belady의 모순이 발생하지 않는다.
- 알고리즘 중 가장 낮은 페이지 부재율을 보장한다.
- 모든 프로세스의 메모리 참조 계획을 미리 파악할 수 없기 때문에 구현의 어려움이 있다.
<br><br><br>

#### LRU (Least Recently Used)
```
가장 오랫동안 사용되지 않은 페이지를 찾아 교체하는 방식의 알고리즘
```

##### 특징
- 최적 알고리즘의 방식과 비슷한 효과를 낼 수 있다.
- 과거의 데이터를 바탕으로 가장 오랜 기간 사용되지 않은 페이지를 찾아 교체한다.
- OPT 보다 페이지 교체 횟수가 높지만, FIFO 보다 효율적이다.
<br><br><br>

#### LFU (Least Frequently Used)
```
참조 횟수가 가장 적은 페이지를 교체하는 알고리즘
```

##### 특징
- 활발하게 사용되는 페이지는 참조 횟수가 많아질 것이라는 가정에서 만들어진 알고리즘이다.
- 어떤 프로세스가 특정 페이지를 집중적으로 사용하다, 다른 기능을 사용하게 되면 더 이상 사용하지 않아도 계속 메모리에 머물러 있게 되어 초기 가정과 어긋나는 시점이 발생할 수 있따.
- OPT 에 근사하지 못하기 때문에, 잘 사용하지 않는다.
<br><br><br>

#### NUR (Not Used Recently)
```
최근에 사용하지 않은 페이지를 교체하는 알고리즘
```

##### 특징
- LRU 를 근사시킨 알고리즘이며, LRU 는 가장 오래전에 참조된 페이지를 교체하는 것에 비해, NUR 은 오랫동안 사용하지 않은 페이지중 하나를 교체한다.
- 각 페이지마다 두 개의 비트(참조 비트, 변형 비트) 가 사용된다.
- 참조 비트 : 페이지가 참조되지 않았을 때는 0, 호출되었을 때는 1로 지정
- 변형 비트 : 페이지의 내용이 변경되지 않았을 때는 0, 변경되었을 때는 1로 지정
- 이 알고리즘은 하드웨어적인 자원으로 동작하기 때문에 LRU 에 비해 교체 페이지의 선정이 훨씬 빠르게 결정된다.
<br><br><br>

#### MFU (Most Frequently Used)
```
참조 횟수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로도 계속 사용될 것이라는 가정에 기반한다.
```

##### 특징
- OPT 에 근사하지 못하기 때문에, 잘 쓰이지 않는다.
