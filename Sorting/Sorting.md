# Sorting 
<br><br>

## Comparisons Sorting(비교 방식 알고리즘)
- ### Bubble Sort(버블 정렬)
  - 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘으로, 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.
  - 선택 정렬과 기본 개념이 유사하다.
  - 제자리 정렬인 `in-place sorting` 방식의 알고리즘
    <br>
    
    | Space Complexity | Time Complexity |
    | :--------------: | :-------------: |
    |       O(1)       |     O(n^2)      |

  - #### 장점
    - 구현이 매우 간단하다 
  - #### 단점
    - 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다
    - 특정 요소가 최종 정렬 위치에 이미 위치해 있는 경우라도 index가 변경될 수 있다 
    <br><br><br>

- ### Selection Sort(선택 정렬)
  - 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘
  - 제자리 정렬인 `in-place sorting` 방식의 알고리즘
    <br>

    | Space Complexity | Time Complexity |
    | :--------------: | :-------------: |
    |       O(1)       |     O(n^2)      |
  - #### 장점
    - 자료 이동 횟수가 미리 결정된다
  - #### 단점
    - 안정성을 만족하지 않는다`[= 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있다]`  
  <br>

  - #### 과정
  1. 주어진 배열 중에서 최솟값을 찾는다
  2. 그 값을 맨 앞에 위치한 값과 교체한다(Pass)
  3. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.
  4. 하나의 원소만 남을 때 까지 위의 1~3 과정을 반복한다.     
<br><br><br>

- ### Insertion sort(삽입 정렬)
  - 배열의 모든 요소를 `앞에서부터 차례대로 이미 정렬된 배열 부분과 비교` 하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘
  - 매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.
    <br>
    | Space Complexity | Time Complexity |
    | :--------------: | :-------------: |
    |       O(1)       |     O(n^2)      |
  - #### 장점
    - 안정한 정렬 방법
    - 레코드의 수가 적을 경우 유리하다
    - 이미 정렬되어 있는 배열의 경우 효율적이다
  - #### 단점
    - 비교적 많은 레코드들의 이동을 포함한다
    - 레코드 수가 많고 레코드 크기가 클 경우 효율이 떨어진다
  <br>

  - #### 과정
    1. 삽입 정렬은 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다
    2. 두 번째 자료는 `첫 번째 자료`, 세 번째 자료는 `두 번째와 첫 번째 자료`, 네 번째 자료는 `세번째, 두번째, 첫번째 자료` 와 비교한 후 자료가 삽입될 위치를 찾았다면, 그 위치에 자료를 삽입하기 위해 배열의 자료들을 한 칸씩 뒤로 옮긴다.
    3. <b>처음 Key 값은 두 번째 자료부터 시작한다</b> 
<br><br><br>

- ### Merge sort(합병 정렬)
  - `안정 정렬`에 속하며 `분할 정복 알고리즘` 의 하나이다 
    - <b>`분할 정복`</b>
      - 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략.
      - 대게 `순환 호출`을 이용하여 구현한다   
  - 합병 정렬의 단계들
    - 분할(Divide) : 입력 배열을 2등분한다. (= 재귀적 구현을 위해 2등분 한다)
    - 정복(Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 `순환 호출` 을 이용하여 다시 분할 정복 방법을 적용한다.
    - 결합(Combine) : 정렬된 부분 배열들을 하나의 배열에 합병한다.
  - 각 부분의 배열을 정렬할 때도 합병 정렬을 순환적으로 호출하여 적용한다
  - 실제로 정렬이 이루어지는 시점은 2개의 리스트를 합병(Merge)하는 단계.
    <br>
    | Space Complexity | Time Complexity |
    | :--------------: | :-------------: |
    |       O(n)       |     O(nlog n)   |
    
  - #### 장점
    - 입력 데이터가 무엇이든 간에 정렬되는 시간은 `O(nlog n)`으로 동일하다.
  - #### 단점
    - 임시 배열이 필요하기 때문에 추가적인 메모리가 필요하다. 
  <br>

  - #### 과정
    1. 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다.
    2. 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
    3. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
    4. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.  
<br><br><br>

- ### Heap sort(힙 정렬)
  - `완전 이진 트리` 자료구조인 `Heap`을 이용해 sorting.
  - 두 가지 방법으로 구현 가능하다.
    1. 정렬의 대상인 데이터들을 Heap에 넣었다가 꺼내는 원래로 sorting.  
    2. 기존의 배열을 `heapify`(heap 으로 만들어주는 과정)을 거쳐 꺼내는 원리로 sorting.
  - Heap에 데이타를 저장/삭제 하는 복잡도는 `O(log n)` 이므로 자료가 n개일 때 시간복잡도는 `O(nlog n)` 이 된다.
    <br>
    | Space Complexity | Time Complexity |
    | :--------------: | :-------------: |
    |       O(1)       |     O(nlog n)   |

  - #### 장점
    - 추가적인 메모리가 필요 없이도 항상 `O(nlog n)` 의 복잡도를 갖는다.
  - #### 단점
    - 실제 시간을 측정해보면 `퀵 정렬` 보다 느리다. 즉, 데이타의 상태에 따라 다른 정렬들에 비해 느려질 수 있다.
    - 그러므로 안정성을 보장받지 못한다.
  <br>

  - #### 과정
    - [1번 방법] 오름차순 정렬을 위해서는 `최소 힙` 을 구현한 뒤, Heap에서 차례대로 데이타를 빼와 정렬할 배열에 넣어준다.
    - [2번 방법]
      1. 정렬되지 않은 배열을 `heapify`를 통해 `최대 힙` 으로 구성한다.
      2. `최대 힙` 의 root node와 마지막 node를 바꾼다.
      3. 마지막 node를 제외한 나머지 node들로 1번부터 다시 수행한다.
<br><br><br>

- ### Quick sort(퀵 정렬)
  - 분할 정복 알고리즘의 하나로, 평균적으로 매우 빠른 수행 속도를 자랑하는 알고리즘.
  - `Merge sort` 와는 다르게 `Quick sort` 는 List를 비 균등하게 분할한다.
    <br>
    | Space Complexity | Time Complexity |
    | :--------------: | :-------------: |
    |       O(log n)       |     O(nlog n)   | 
  - #### 장점
    - 속도가 빠르다 [시간복잡도가 `O(nlog n)` 을 가지는 다른 정렬 알고리즘보다 빠르다]
    - 추가적인 메모리 공간이 필요없다
  - #### 단점
    - 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 길어진다
    - Partition 과정에서 피벗이 항상 배열에서 가장 작거나, 클 경우 `Worst Case` 가 발생한다.
      - 이렇게 Partition이 되면 비교 횟수는 원소 n 개에 대하여 n번, n-1번, n-2번...이 되므로 시간 복잡도는 `O(n^2)` 이 된다. 
  <br>

  - #### 단점의 해결과정
    - 퀵 정렬의 불균형 분할을 방지하기 위해 피벗을 리스트에서의 중간값으로 선택한다. 
    - 특정 위치의 원소를 피벗으로 설정하지 않고 배열 내의 원소중 임의의 원소를 피벗으로 설정하면 입력에 관계없이 일정한 수준의 성능을 얻을 수 있다. 또한 악의적인 입력에 대해 성능 저하를 막을 수 있다.
  <br>

  - #### 과정
  1. 리스트 안에 있는 한 요소 ` = 피벗[Pivot]`를 선택한다.
  2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고, 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다.
  3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
     - 분할된 부분 리스트에 대하여 `재귀 호출` 을 이용하여 정렬을 반복한다.
  4. 부분 리스트가 분할이 불가능할 때까지 반복한다. 
<br><br><br>



## 복잡도
![스크린샷 2020-12-14 오후 4 46 03](https://user-images.githubusercontent.com/56511253/102054141-41e5e280-3e2c-11eb-8b8c-6a1e528461d1.png)
<br><br>

## 🦄 용어
1. **제자리 정렬** : 주어진 메모리 공간 외에 추가적인 공간을 필요로 하지 않는 정렬 방식
2. **안정 정렬** : 정렬 후에 같은 값인 요소의 순서가 보장되는 정렬 방식
3. **불안정 정렬** : 정렬 후에 같은 값인 요소의 순서가 보장되지 않는 정렬 방식