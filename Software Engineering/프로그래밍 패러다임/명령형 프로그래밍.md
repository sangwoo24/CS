# 명령형 프로그래밍

- #### 프로그래밍의 상태와, 상태를 변경시키는 구문의 관점에서 연산을 설명하는 프로그래밍 패러다임.<br>
- #### 무엇 (What) 을 할 것인지 나타내기보다 어떻게 (How) 할 건지를 설명하는 방식
<br><br>

## 1. 절차지향 프로그래밍
- 프로그램의 실행 절차에 중점을 둔 프로그래밍 기법이다.
- 대표적인 언어 : C
<br>

### 1-1 특징
- 같은 코드를 다른 장소에서 다시 사용할 수 있게 해준다.
- 모듈화를 하거나 구조화를 할 수 있다.
- 객체지향 프로그래밍과 비교하여 속도가 빠른편이다.
- 유지보수가 어렵다.
- 프로그램의 분석과 디버깅이 어렵다.
- 코드의 순서가 바뀌면 의도한 대로 프로그램이 동작하지 않을 수 있다.
<br><br>

## 2. 객체지향 프로그래밍
- 컴퓨터 프로그램을 명령어의 목록으로 보는 기존의 명령형 프로그래밍 패러다임의 시각에서 벗어나, 여러 개의 독립된 단위인 "객체의 모임" 으로 파악하고자 하는 시각이다.
- 각각의 객체는 서로 메세지를 주고받으며, 데이터를 처리할 수 있다.
- 대표적인 언어 : 스몰토크(smaltalk), Objective-C, C++, C#, Java, Ruby, Python, Swift
<br>

### 2-1 구성 요소
- **클래스** : 같은 종류의 집단에 속하는 속성과 행위를 정의한 것.
- **객체** : 클래스의 인스턴스
- **메세지** : 객체 사이의 명령 전달 및 데이터 처리를 위해 필요한 것.
<br>

### 2-2 특징
- 개발과 유지보수가 간편.
- 대규모 소프트웨어 개발에 사용.
- 직관적인 코드 분석을 가능하게 한다.
- 객체 간의 정보 교환이 모두 메세지를 통해 일어나므로 오버헤드가 발생한다.
- 객체가 예측할 수 없는 상태를 갖게되면 Application 내부에서 버그를 발생시킨다.
<br>

#### 1. 자료 추상화 (Abstraction)
> 필요로 하는 속성이나 행동들을 추출함으로써 프로그램을 간단히 만드는 것.
- 세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만들어내는 것.
```
ex. 아우디, BMW, 벤츠는 모두 '자동차' 라는 공통점이 있다.

자동차라는 추상화 집합을 만들어두고, 자동차들이 가진 공통적인 특징들을 만들어 활용한다.
```
<br>

#### 2. 캡슐화 (Encapsulation)
> 높은 응집도와 낮은 결합도를 유지할 수 있도록 설계하는 것.
- **정보 은닉** 을 활용하여, 외부로부터 객체 내의 멤버변수에 직접적인 접근을 제한시키는 것을 의미한다.
<br>

#### 3. 상속 (Inheritance)
> 새로운 클래스가 기존의 클래스의 자료와 연산을 이용할 수 있게 하는 기능.

<br>

#### 4. 다형성 (Polymorphism)
> 하나의 클래스나 메소드가 다양한 방식으로 동작이 가능한 것을 의미.
- **오버라이딩** : 같은 이름의 메소드가 여러 클래스에서 다른 기능을 하는 것.
- **오버로딩** : 같은 이름의 메소드가 인자의 개수나 자료형에 따라서 다른 기능을 하는 것.
<br><br><br>



### 2-3 객체 지향적 설계 원칙

#### 1. SRP (Single Responsibility Principle) : 단일 책임 원칙
- 클래스는 단 하나의 책임을 가져야 하며, 클래스를 변경하는 이유는 단 하나의 이유여야 한다.
- 책임을 많이 질수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합될 가능성이 높아진다.
<br>

#### 2. OCP (Open - Closed Principle) : 개방 - 폐쇄 원칙
- 확장에는 열려 있어야 하며, 변경에는 닫혀 있어야 한다.
- 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계가 되어야 한다.
<br>

#### 3. LSP (Liskov Substitution Principle) : 리스코프 치환 원칙
- 상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
- 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
<br>

#### 4. ISP (Interface Segregation Principle) : 인터페이스 분리 원칙
- 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
- 클라이언트 자신이 이용하지 않는 기능에는 영향을 받지 않아야 한다.
<br>

#### 5. DIP (Dependency Inversion Principle) : 의존 역전 원칙
- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
- 의존 관계를 맺을 때, 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운것, 거의 변화가 없는것에 의존하나는 것.
- **클래스의 의존 관계** : 한 클래스가 어떤 기능을 수행하려고 할 때, 다른 클래스의 서비스가 필요한 경우