# QUEUE
- 먼저 넣은 데이터가 먼저 나오는 FIFO(First In First Out) 형식의 자료구조
<br><br><br>

## 특징
- 선형 자료구조의 일종이다.
- 큐에 새로운 Data가 들어오면 enqueue를, Data가 삭제될 때는 dequeue를 수행.
- 맨 앞은 Front, 맨 뒤는 Rear로 불린다.

## 활용
- 주로 **컴퓨터 버퍼**에 사용되며 입력이 초과되어 작업을 진행하지 못할 시, **버퍼(큐)**를 만들어서 대기시킨 후 추후에 순차적으로 작업을 진행.
- 데이터를 추가한 순서대로 제어할 수 있기 때문에 스트리밍(Streaming), 너비 우선 탐색(BFS), 프로세스 스케줄링, 캐시(Cache), 우선순위가 같은 작업 등에 사용.

<br><br><br>

## 1. 선형 큐

<center>
<img width="412" alt="스크린샷 2020-10-07 오후 5 32 35" src="https://user-images.githubusercontent.com/56511253/95307034-1cd07300-08c3-11eb-9887-c93dd7cba5c0.png">
</center>

- 1부터 5까지 차례대로 들어온 것이며 `dequeue`연산을 하게 되면 1이 출력된다.
<br>

<center>

![스크린샷 2020-10-07 오후 5 28 57](https://user-images.githubusercontent.com/56511253/95306667-a9c6fc80-08c2-11eb-8e91-bd34fafd148e.png)
</center>


- `선형 큐`에서 삽입 및 삭제를 반복하다 보면, `rear`가 맨 마지막 인덱스를 가리키고, 나머지 앞부분은 비어 있을 수 있지만 이를 꽉찼다고 인식해버린다 --> `메모리 낭비`
   - 실제 데이터는 삭제 때마다 한 칸 앞으로 이동시키지 않았고, 인덱스 단위로 큐의 연산을 진행했기 때문.
- 또한 `선형 큐`는 큐에 Data가 꽉 찼다면 더 추가할 수 없다.
- 이러한 문제점들을 해결하기 위해 `원형 큐`를 사용한다.
<br><br>

### 1-1. 선형 큐 시간복잡도
> - 배열의 값을 이동시키는 이동 큐의 경우 삽입/삭제가 O(n)이 될 수 있다.
- 삽입/삭제 : O(1)
- 탐색 : O(n)
- 접근 : O(1)
<br><br><br><br>

## 2. 원형큐
<center><img width="408" alt="스크린샷 2020-10-07 오후 5 43 40" src="https://user-images.githubusercontent.com/56511253/95308266-a59bde80-08c4-11eb-89f5-6134d1ff3b32.png"></center>

- 선형 큐와 동일하게 1차원 배열을 이용하지만 처음과 끝이 원형처럼 이어져 있다고 가정한다.
- 큐를 원형으로 생각해야하기 때문에 mod연산을 사용해야한다.
- 선형 큐에서는 필요했던, 삭제 시 데이터들을 한번씩 앞당겨주는 불필요한 작업들을 없앨 수 있다.
### 장점
- 선형큐와 비교했을 때 공간을 낭비하지 않는다.
- 이동큐와 비교했을 때 배열의 값을 이동시켜줄 필요가 없다.
  
### 단점
- 배열로 구현하기 때문에 크기가 정해져 있다.
- 1개의 공간이 낭비된다.

### 해결방안
- Linked List Queue로 보완.
<br><br><br><br>

## 3. Linked 큐
- Linked List 를 이용해 Queue를 구현
![스크린샷 2020-10-07 오후 10 09 08](https://user-images.githubusercontent.com/56511253/95334957-ba3e9d80-08e9-11eb-9102-0186a88df88f.png)
### 장점
- 배열과 다르게 추가, 삭제시 유연성이 생기기 때문에 배열보다 공간을 효율적으로 이용 가능하다.  
- 배열에선 원소를 dequeue하게되면 원소들을 하나씩 밀어넣어줘야 하지만, Linked List는 삽입과 삭제가 바로 이루어짐.  
<br><br><br><br>

## 4. Priority 큐(우선순위 큐)
- 비 선형 자료구조인 Heap 과 선형 자료구조인 Array/LinkedList로 구현할 수 있다.
- 들어온 순서와 상관없이 우선순위가 가장 높은 Data가 출력됨.
- 최대, 최소값을 찾는 경우 많이 이용됨.
<br><br>

#### 4-1. 배열을 이용한 우선순위 큐
- 간단하게 구현 가능.
- 데이터 삽입 및 삭제과정에서 데이터를 한 칸씩 당기거나 밀어야 하는 연산을 계속 해야한다.
- 삽입 할 위치를 찾기 위해 배열에 저장된 모든 데이터와 우선순위를 비교해야 한다.
<br>

#### 4-2. 연결리스트를 이용한 우선순위 큐
- 삽입 할 위치를 찾기 위해 배열에 저장된 모든 데이터와 우선순위를 비교해야 한다.
<br>

#### 4-3. 힙을 이용한 우선순위 큐
- 완전 이진 트리인 힙으로 구현한다.
- 배열과 연결리스트에서 발생하는 삽입 시 복잡도의 문제로 힙을 통해 구현한다.
- 삭제나 삽입 과정에서 모두 부모와 자식 간의 비교만 하게 된다.
<br>

#### 4-3. 복잡도 비교
- 배열 / 연결리스트
  - 정렬된 배열의 경우(삽입할 요소의 우선순위를 비교하면서 삽입해야함)
    - 삽입 O(n), 삭제 O(1)
  - 정렬되지 않은 배열의 경우(마지막 요소의 그냥 넣지만 삭제할 때 모든 원소와 우선순위를 따진다)
    - 삽입 O(1), 삭제 O(n)
<br>

- 힙
  - 삽입 / 삭제 : O(log n)